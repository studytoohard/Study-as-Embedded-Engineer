1.指针间传递地址是不可取的
2.指针数组名默认为指针数组的第一个值的地址，输出指针名即输出第一个值
3.指向字符的指针的指针名默认为第一个值中第一个字符的地址（&var)，输出指针名（var)即输出该值，可以通过*（var+）获取各个字符
4.为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。
5.::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。
6.using 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间
7.很多教程中都是这样做的，将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，
我推荐在函数内部声明 std。
8.在 C++ 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。
9.最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。
编译器有自己的判断能力，它会根据具体情况决定是否这样做。
10.允许函数默认参数值，是为了让编程简单，让编译器做更多的检查错误工作。
11.在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。
12.根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，
而只将允许通过对象调用的成员函数声明为 public。
13.成员变量声明为private而不是public的原因：
  1. 能够提供语法一致性，写代码的时候能够马上区分要不要加函数括号；
  2. 提供更好的访问控制，只读、只写还是可读可写，都容易控制；
  3. 封装，减少与外界接触的机会，方便修改和维护。
14.成员变量加了const修饰，只能使用参数初始化表的方式赋值。
15.函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。在函数内部创建的对象是局部对象，
它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。new 创建的对象位于堆区，
通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。
16.this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，
而是在编译阶段由编译器默默地将它添加到参数列表中。this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，
并且只有在通过对象调用成员函数时才给 this 赋值。
17.static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象
修改了 m_total，也会影响到其他对象。static 成员变量必须在类声明的外部初始化，具体形式为：type class::name = value。注意：static 
成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 
成员变量不能使用。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。
18.初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，
而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。
19.静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，
只能访问静态成员（包括静态成员变量和静态成员函数）。
20.需要注意的是，必须在成员函数的声明和定义处同时加上 const 关键字。
21.const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员了。
22.借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。
23.注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。
24.这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。
25.因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），
才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）
或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。
26.一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。
27.除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。
28.在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。
29.C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针
30.在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型
31.有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（Reference）。
32.引用在定义时需要添加&，在使用时不能添加&，使用时添加&表示取地址
