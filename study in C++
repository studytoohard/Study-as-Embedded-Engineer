1.指针间传递地址是不可取的
2.指针数组名默认为指针数组的第一个值的地址，输出指针名即输出第一个值
3.指向字符的指针的指针名默认为第一个值中第一个字符的地址（&var)，输出指针名（var)即输出该值，可以通过*（var+）获取各个字符
4.为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。
5.::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。
6.using 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间
7.很多教程中都是这样做的，将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，
我推荐在函数内部声明 std。
8.在 C++ 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。
9.最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。
编译器有自己的判断能力，它会根据具体情况决定是否这样做。
10.允许函数默认参数值，是为了让编程简单，让编译器做更多的检查错误工作。
11.在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。
12.根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，
而只将允许通过对象调用的成员函数声明为 public。
13.成员变量声明为private而不是public的原因：
  1. 能够提供语法一致性，写代码的时候能够马上区分要不要加函数括号；
  2. 提供更好的访问控制，只读、只写还是可读可写，都容易控制；
  3. 封装，减少与外界接触的机会，方便修改和维护。
14.成员变量加了const修饰，只能使用参数初始化表的方式赋值。
15.函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。在函数内部创建的对象是局部对象，
它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。new 创建的对象位于堆区，
通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。
