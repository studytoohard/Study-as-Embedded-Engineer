1.指针间传递地址是不可取的
2.指针数组名默认为指针数组的第一个值的地址，输出指针名即输出第一个值
3.指向字符的指针的指针名默认为第一个值中第一个字符的地址（&var)，输出指针名（var)即输出该值，可以通过*（var+）获取各个字符
4.为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。
5.::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。
6.using 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间
7.很多教程中都是这样做的，将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，
我推荐在函数内部声明 std。
8.在 C++ 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。
9.最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。
编译器有自己的判断能力，它会根据具体情况决定是否这样做。
10.允许函数默认参数值，是为了让编程简单，让编译器做更多的检查错误工作。
11.在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。
12.根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，
而只将允许通过对象调用的成员函数声明为 public。
13.成员变量声明为private而不是public的原因：
  1. 能够提供语法一致性，写代码的时候能够马上区分要不要加函数括号；
  2. 提供更好的访问控制，只读、只写还是可读可写，都容易控制；
  3. 封装，减少与外界接触的机会，方便修改和维护。
14.成员变量加了const修饰，只能使用参数初始化表的方式赋值。
15.函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。在函数内部创建的对象是局部对象，
它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。new 创建的对象位于堆区，
通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。
16.this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，
而是在编译阶段由编译器默默地将它添加到参数列表中。this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，
并且只有在通过对象调用成员函数时才给 this 赋值。
17.static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象
修改了 m_total，也会影响到其他对象。static 成员变量必须在类声明的外部初始化，具体形式为：type class::name = value。注意：static 
成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 
成员变量不能使用。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。
18.初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，
而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。
19.静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，
只能访问静态成员（包括静态成员变量和静态成员函数）。
20.需要注意的是，必须在成员函数的声明和定义处同时加上 const 关键字。
21.const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员了。
22.借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。
23.注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。
24.这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。
25.因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），
才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）
或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。
26.一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。
27.除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。
28.在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。
29.C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针
30.在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型
31.有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（Reference）。
32.引用在定义时需要添加&，在使用时不能添加&，使用时添加&表示取地址
33.按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，我鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），
C++ 标准库也是这样做的。
34.将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会
被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。
35.面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。
36.抽象：把现实的对象属性转化成数据映射到类上
37.封装：相当于一个盒子，知道是干嘛用的，不用管盒子子里面是什么
38.接口：基于封装，只留给用户使用的方法，这些方法就是接口
39.继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数。
被继承的类称为父类或基类，继承的类称为子类或派生类。
40.现在我们知道，public、protected、private 三个关键字除了可以修饰类的成员，还可以指定继承方式。
41.类成员的访问权限由高到低依次为 public --> protected --> private
42.protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：
基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用
43.基类成员在派生类中的访问权限不得高于继承方式中指定的权限。也就是说，继承方式中的 public、protected、private 
是用来指明基类成员在派生类中的最高访问权限的。
44.如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；
只有那些不希望在派生类中使用的成员才声明为 private。
45.如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。
46.实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。
47.使用 using 关键字可以改变基类成员在派生类中的访问权限
48.如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员
（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。
49.被遮蔽的函数仍然可以访问，不过要加上类名和域解析符
50.基类成员函数和派生类成员函数不构成重载，构成遮蔽
51.只能将基类构造函数的调用放在函数头部，不能放在函数体中。
52.派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。
53.显式定义了构造函数，编译器不会再生成默认的构造函数。
54.换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。
55.因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承
56.在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，
虚基类是间接基类，而不是直接基类。
57.C++ 干脆规定必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。
58.类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象
赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类
赋值给派生类称为向下转型（Downcasting）。
59.赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。
60.对象之间的赋值不会影响成员函数，也不会影响 this 指针。
61.这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。
62.编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。
63.通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。
64.为了让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function）。
65.有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照
基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。
66.C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。
如果没有多态，我们只能访问成员变量。
67.不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。
68.对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。
69.可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。
70.当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。
71.只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。
72.下面是构成多态的条件：
    必须存在继承关系；
    继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。
    存在基类的指针，通过该指针调用虚函数。
73.通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。
74.什么时候声明虚函数：首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为
虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。
75.C++虚析构函数的必要性：为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
76.对象的静态类型：对象在声明时采用的类型。是在编译期确定的。 
   对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
   静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。 
   动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。   
77.
