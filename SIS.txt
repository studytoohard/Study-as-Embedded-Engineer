-------------------------2017/10/27----	
	AOP：Aspect Oriented Programming 面向切片编程 aspect 方面
	IOC：Inversion of Control 控制反转
	POJO（Plain Ordinary Java Object）简单的Java对象

-------------------------2017/10/31----
	修改的html自动刷新
	-Dorg.apache.tapestry.disable-caching=true -Dorg.apache.tapestry.enable-reset-service=true

-------------------------2017/11/12----
	DI能够让相互协作的软件组件保持松散耦合， 而面向切面编程
	（aspect-oriented programming， AOP） 允许你把遍布应用各处的功能
	分离出来形成可重用的组件。

	ORM（Object-Relational Mapping）
	JMS（Java Message Service）

	Spring模块：1.Spring核心容器
				2.Spring的AOP模块
				3.数据访问与集成
				4.Web与远程调用
				5.Instrumentation 
				6.测试
	Spring Portfolio：Spring组合包

-------------------------2017/11/14----
	构造器注入Bean引用
   "1. <constructor-arg ref="compactDisc" />
	2. <bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
    3. <bean id="cdPlayer" class="soundsystem.CDPlayer" c:_-ref="compactDisc" />

    该选择构造器注入还是属性注入呢？ 作为一个通用的规则， 我倾向于
对强依赖使用构造器注入， 而对可选性的依赖使用属性注入
。
    Spring XML实现属性注入
    在JavaConfig中引用XML配置 @ContextConfiguration(classes=SoundSystemConfig.class)
    @Import(CDPlayerConfig.class)
	@ImportResource("classpath:main/resources/cd-config.xml")
    在XML配置中引用JavaConfig @ContextConfiguration("classpath:main/resources/cdplayer-config.xml")
    <bean class="soundsystem.CDConfig" />
    <import resource="cdplayer-config.xml"/>"

-------------------------2017/11/16----
	JNDI：Java命名和目录接口 Java Naming and Directory Interface
	记得看注释
	@Profile 注解指定某个bean属于哪一个profile。 
	@ActiveProfiles 注解，我们可以使用它来指定运行测试时要激活哪个profile。 
	@Conditional 注解，它可以用到带有@Bean注解的方法上。 如果给定的条件计算结果为true， 就会创建这个bean，否则的话， 这个bean会被忽略。
	@Autowired 注解，自动装配
	@Component 注解，在@ComponentScan组件扫描的时候， 能够发现它们并将其创建为Spring应用上下文里面的bean。 
	@Primary 能够与@Component组合用在组件扫描的bean上，也可以与@Bean组合用在Java配置的bean声明中。 将@Component注解的IceCream bean声明为首选的bean
	@Qualifier 注解是使用限定符的主要方式。 它可以与@Autowired和@Inject协同使用， 在注入的时候指定想要注入进去的是哪个bean。 

	在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton） 的形式创建的。 也就是说， 不管给定的一个bean被注入到其他bean多少次， 每次所注入的都是同一个实例。

	@ComponentScan(excludeFilters={@Filter(type=FilterType.ANNOTATION, value=Configuration.class)})过滤掉有@Configuration注解的类（如果里面有@Bean则不会冲突）

-------------------------2017/11/18----
	单例（Singleton）： 在整个应用中， 只创建bean的一个实例。
	原型（Prototype）： 每次注入或者通过Spring应用上下文获取的
	时候， 都会创建一个新的bean实例。
	会话（Session）： 在Web应用中， 为每个会话创建一个bean实
	例。
	请求（Rquest）： 在Web应用中， 为每个请求创建一个bean实
	例。
	@Scope 声明bean类型
	@PropertySource("classpath:/com/soundsystem/app.properties")声明属性源
	
	env.getRequiredProperty("disc.artist"));得到的属性必须要定义否则抛出IllegalStateException异常
	@Test(expected=BeanCreationException.class)表示期望抛出的一个异常
	@Value()指定占位符用于组件扫描和自动装配来创建和初始化应用组件
	xml方式解析占位符<context:property-placeholder location="com/soundsystem/app.properties" />
	SpringEL：#{T(java.lang.Math).random()}
面向切片的Spring
	1.在软件开发过程中，散布于应用多处的功能被称为横向关注点（cross-cutting-concern）如：日志、安全、事务管理
	2.重用通用功能最常见的面向对象技术是继承（inheritance）或委托（delegation）但是， 如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系； 而使用委托可能需要对委托对象进行复杂的调用。切面提供了取代继承和委托的另一种可选方案， 而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用， 而无需修改受影响的类。 横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处： 首先， 现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁， 因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。
	3.切面实现了横切关注点（跨多个应用对象的逻辑） 的模块化

-------------------------2017/11/21----	
	描述切面的术语:
		通知(ACTIVE)
			切面的工作称为通知，通知定义了切面是什么以及何时使用。
			五种类型的通知：
				前置通知（Before）：
				后置通知（After）：
				返回通知（After-returning）：
				异常通知（After-throwing）：
				环绕通知（Around）：
		连接点(Join point)
			可以应用通知的时机被称为连接点
		切点(Pointcut)
			切点定义了切面在何处通知
		切面(Aspect)
			切面是通知和切点的结合
		引入(Introduction)
			引入允许我们向现有的类添加新方法或属性。新方法和实例变量可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让他们具有新的行为和状态。
		织入(Weaving)
			织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：
			1.编译期： 切面在目标类编译时被织入。 这种方式需要特殊的编译器。 AspectJ的织入编译器就是以这种方式织入切面的。
			2.类加载期： 切面在目标类加载到JVM时被织入。 这种方式需要特殊的类加载器（ClassLoader） ， 它可以在目标类被引入应用之前增强该目标类的字节码。 AspectJ 5的加载时织入（load-time weaving， LTW） 就支持以这种方式织入切面。
			3.运行期： 切面在应用运行的某个时刻被织入。 一般情况下， 在织入切面时， AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。
		Spring AOP提供的4种类型的AOP支持
			1.基于代理的经典Spring AOP
			2.纯POJO切面
			3.@AspectJ注解驱动的切面
			4.注入式AspectJ切面（适用于Spring各版本）
		Spring AOP构建在动态代理基础上，因此Spring对AOP的支持局限于方法拦截
		Spring通知是Java编写的
		Spring在运行时通知对象
		Spring只支持方法级别的连接点
			但是方法拦截可以满足绝大部分的需求。 如果需要方法拦截之外的连接点拦截功能， 那么我们可以利用Aspect来补充Spring AOP的功能。
	通过切点选择连接点	
		编写切点 限制匹配
			<aop:pointcut id="id" expression="execution(type package.class.function(arg)) && within(package.*)" />
		在切点中选择bean 匹配指定id的bean
			<aop:pointcut id="id1" expression="execution(type package.class.function(arg)) && within(package.*) and bean('id2')" />
	使用注解创建切面：
		@Aspect 创建切面
		@Pointcut("execution(** concert.Performance.perform(..))") 创建切点
		@Before("performance()") @AfterReturning("performance()") @AfterThrowing("performance()") 创建通知
		@EnableAspectJAutoProxy 启用代理
		将声明为@Aspect的POJO同时声明为@Component使用@EnableAspectJAutoProxy时会产生两个代理

-------------------------2017/11/22----
	1.切面捕捉某一方法不能捕捉方法内调用的该方法		
	通过注解引入新的功能
		使用Spring AOP， 我们可以为bean引入新的方法。代理拦截调用并委托给实现该方法的其他对象
		@DeclareParents
	Spring配置文件xml头部配置解释
		xml（Extensible Markup Language）可扩展标记语言
		xsd（XML Schema Definition）xml实例描述
		xmlns（XML Namespaces）xml命名空间
		xsi（xml schema instance）xml模式实例（元素所准守的规范）
		使用一个标签元素前声明方式：
			1.xmlns:aop="http://www.springframework.org/schema/aop"
			2.xsi:schemaLocation="http://www.springframework.org/schema/aop 
								  http://www.springframework.org/schema/aop/spring-aop.xsd"
	Spring配置文件xml标签解析逆推
		xml头部配置->命名空间(spring.schemas)->spring-命名空间.xsd->对应标签映射(spring.handles)->		路径.xxxNamespaceHandler(xxxNamespaceHandler extends NamespaceHandlerSupport)->具体子标签解析类(xxxBeanDefinitionParser implements BeanDefinitionParser)->匹配具体标签对应方法[BeanDefinition parse(Element element, ParserContext parserContext)]->String localName = parserContext.getDelegate().getLocalName(elt);
			  if ("pointcut".equals(localName)) {
			      parsePointcut(elt, parserContext);
			  } ->实例化[this.parseState.push(new PointcutEntry(id));]

	在XML中声明切面
		这样一种原则，那就是基于注解的配置要优于基于Java的配置， 基于Java的配置要优于基于XML的配置。但是，如果你需要声明切面， 但是又不能为通知类添加注解的时候，那么就必须转向XML配置了。
